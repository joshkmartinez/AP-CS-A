<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Javanotes 8.0, Section 13.3 -- Complex Components and MVC</title>
<link type="text/css" rel="stylesheet" href="../javanotes.css">
</head>
<body>
<div class="page">
<div align="right">
<small>
        [  <a href="s2.html">Previous Section</a> |
           <a href="s4.html">Next Section</a> |
           <a href="index.html">Chapter Index</a> | 
        <a href="../index.html">Main Index</a> ]
    </small>
</div>
<hr>
<table class="subsections" vspace="8" hspace="8" cellpadding="5" border="2" align="right">
<tr>
<td>
<div align="center">
<b>Subsections</b>
<hr>
<small><a href="#GUI2.3.1">A Simple Custom Component</a>
<br>
<a href="#GUI2.3.2">The MVC Pattern</a>
<br>
<a href="#GUI2.3.3">ListView and ComboBox</a>
<br>
<a href="#GUI2.3.4">TableView</a>
<br>
</small>
</div>
</td>
</tr>
</table>
<div class="content">
<h3 class="section_title">Section 13.3</h3>
<h2 class="section_title">Complex Components and MVC</h2>
<hr class="break">
   

<p>
<span class="start"><big>T</big>here is a lot more complexity</span> than we have
seen so far lurking in the JavaFX API.  However, a lot of that
complexity works to your benefit as a programmer, since a lot of it is hidden in
typical uses of JavaFX components.  You don't have to know about the most
complex details of controls in order to use them effectively in most programs.</p>
   

<p>JavaFX defines several component classes that are much more complex than those
we have looked at, but even the most complex components are not very
difficult to use for many purposes.  In this section, we'll look at components
that support display and manipulation of lists and tables.
To use these complex components effectively, it's helpful to know something about
the Model-View-Controller pattern that is used as a basis for the design of
many GUI components.  That pattern is discussed later in this section.</p>


<p>There are a number of JavaFX controls that are not covered in this book.  Some useful
ones that you might want to look into include:  <span class="classname">TabbedPane</span>,
<span class="classname">SplitPane</span>, <span class="classname">Tree</span>, <span class="classname">ProgressBar</span>, and
various specialized input controls such as <span class="classname">ColorPicker</span>,
<span class="classname">DatePicker</span>, <span class="classname">PasswordField</span>,
and <span class="classname">Spinner</span>.</p>
   

<p>We start this section with a short example of writing a custom control&mdash;something 
that you might consider when even the large variety of components that are already
defined in JavaFX don't do quite what you want (or when they do too much,
and you want something simpler).</p>



<hr class="break">
<h3 class="subsection_title">
<a name="GUI2.3.1">13.3.1&nbsp;&nbsp;A Simple Custom Component</a>
</h3>


<p>JavaFX's standard component classes are usually all you need to construct a user
interface. At some point, however, you might need something a bit different.
In that case, you can consider writing your own component class, by building on one of the
components that JavaFX does provide or on the basic <span class="classname">Control</span> class that
serves as the base class for all controls.</p>


<p>For example, suppose I have a need for a "stopwatch" control. When the
user clicks on the stopwatch, I want it to start timing. When the user clicks
again, I want it to display the elapsed time since the first click. The textual
display can be done with a <span class="classname">Label</span>, but we want 
a <span class="classname">Label</span> that
can respond to mouse clicks. We can get this behavior by defining a
<span class="classname">StopWatchLabel</span> component as a subclass of the <span class="classname">Label</span> class. A
<span class="classname">StopWatchLabel</span> object will listen for mouse clicks on itself. The first
time the user clicks, it will change its display to "Timing..." and remember
the time when the click occurred. When the user clicks again, it will check the
time again, and it will compute and display the elapsed time. (Of course, I
don't necessarily have to define a subclass. I could use a regular label in my
program, set up a listener to respond to mouse events on the label, and let the
program do the work of keeping track of the time and changing the text displayed
on the label. However, by writing a new class, I have something that can be
<b>reused</b> in other projects. I also have all the code involved in the stopwatch
function collected together neatly in one place. For more complicated
components, both of these considerations are very important.)</p>


<p>The <span class="classname">StopWatchLabel</span> class is not very hard to write. I need an instance
variable to record the time when the user starts the stopwatch. 
In the mouse event handling method that responds to mouse clicks on the stopwatch, I need
to know whether the timer is being started or stopped, so I need a <span class="ptype">boolean</span>
instance variable, <span class="code">running</span>, to keep track of this aspect of the component's state. 
We can use the method <span class="code">System.currentTimeMillis()</span> to get the current time,
in milliseconds, as a value of type <span class="ptype">long</span>.   When the timer is started,
we can store the current time in an instance variable, <span class="code">startTime</span>.  
When the timer is stopped, we can use the current time and the start time to compute
the elapsed time that the timer has been running.
The complete <span class="code">StopWatch</span> class is very short:</p>


<pre>import javafx.scene.control.Label;

/**
 * A custom component that acts as a simple stop-watch.  When the user 
 * clicks on it, this component starts timing.  When the user clicks again,
 * it displays the time between the two clicks.  Clicking a third time
 * starts another timer, etc.  While it is timing, the label just
 * displays the message "Timing....".
 */
public class StopWatchLabel extends Label {

    private long startTime;   // Start time of timer.
                              //   (Time is measured in milliseconds.)

    private boolean running;  // True when the timer is running.

    /**
     * Constructor sets initial text on the label to
     * "Click to start timer." and sets up a mouse event
     * handler so the label can respond to clicks.
     */
    public StopWatchLabel() {
        super("  Click to start timer.  ");
        setOnMousePressed( e -&gt; setRunning( !running ) );
    }


    /**
     * Tells whether the timer is currently running.
     */
    public boolean isRunning() {
        return running;
    }


    /**
     * Sets the timer to be running or stopped, and changes the text that
     * is shown on the label.  (This method should be called on the JavaFX
     * application thread.)
     * @param running says whether the timer should be running; if this
     *    is equal to the current state, nothing is done.
     */
    public void setRunning( boolean running ) {
        if (this.running == running)
            return;
        this.running = running;
        if (running == true) {
                // Record the time and start the timer.
            startTime = System.currentTimeMillis();  
            setText("Timing....");
        }
        else {
                // Stop the timer.  Compute the elapsed time since the
                // timer was started and display it.
            long endTime = System.currentTimeMillis();
            double seconds = (endTime - startTime) / 1000.0;
            setText( String.format("Time: %1.3f seconds", seconds) );
        }
    }

} // end StopWatchLabel</pre>


<p>Don't forget that since <span class="classname">StopWatchLabel</span> is a subclass of <span class="classname">Label</span>,
you can do anything with a <span class="classname">StopWatchLabel</span> that you can do with a
<span class="classname">Label</span>. You can add it to a container. You can set its font,
text color, max and preferred size, and CSS style. You can set the text that it displays
(although this would interfere with its stopwatch function).</p>


<p>
<span class="sourceref"><a href="../source/chapter13/StopWatchLabel.java">StopWatchLabel.java</a></span> 
is not an application and cannot be run on its own. The very short program <span class="sourceref"><a href="../source/chapter13/TestStopWatch.java">TestStopWatch.java</a></span>
shows a <span class="classname">StopWatchLabel</span>, and it sets several of the label's properties to
improve the appearance.</p>




<hr class="break">
<h3 class="subsection_title">
<a name="GUI2.3.2">13.3.2&nbsp;&nbsp;The MVC Pattern</a>
</h3>


<p>One of the principles of object-oriented design is division of responsibilities.
Ideally, an object should have a single, clearly defined role, with a limited
realm of responsibility.  One application of this principle to the design of
graphical user interfaces is the <span class="newword">MVC pattern</span>.  "MVC" stands
for "Model-View-Controller" and refers to three different realms of responsibility
in the design of a graphical user interface.</p>
   

<p>When the MVC pattern is applied to a component, the <span class="newword">model</span>
consists of the data that represents the current state of the component.
The <span class="newword">view</span> is simply the visual presentation of the
component on the screen.  And the <span class="newword">controller</span> is the
aspect of the component that carries out actions in response to events
generated by the user (or by other sources such as timers).  The idea is to assign responsibility for the
model, the view, and the controller to different objects.</p>
   

<p>The view is the easiest part of the MVC pattern to understand.  It is
often represented by the component object itself, and its responsibility
is to draw the component on the screen.  In doing this, of course, it
has to consult the model, since the model represents the state of the
component, and that state can determine what appears on the screen.
To get at the model data&mdash;which is stored in a separate object
according to the MVC pattern&mdash;the component object needs to keep
a reference to the model object. Furthermore, when the model changes,
the view often needs to be redrawn to reflect the changed state.
The component needs some way of knowing when changes in the model
occur.  Typically, in Java, this is done with events and listeners.  The
model object is set up to generate events when its data changes.
The view object registers itself as a listener for those events. When the model
changes, an event is generated, the view is notified of that event, and the
view responds by updating its appearance on the screen.</p>
   

<p>When MVC is
used for JavaFX components, the controller is generally not so well defined
as the model and view, and its responsibilities are often split
among several objects.  The controller might include mouse
and keyboard listeners that respond to user events on the view, as well as
listeners for other high-level events, such as those from a button or slider,
that affect the state of the component.  Usually, the controller
responds to events by making modifications to the model, and
the view is changed only indirectly, in response to the changes
in the model.</p>
   

<p>The MVC pattern is used in many places in the design of JavaFX,
even when the terms "model" and "view" are not used.  The whole
idea of observable properties (<a href="../c13/s1.html#GUI2.1.1">Subsection&nbsp;13.1.1</a>) is a way
of implementing the idea of a model that is separate from the view,
although when properties are used, the model can be spread over
many different objects.
For the list and table controls that we will look at
next, the model and view are somewhat more explicit.</p>




<hr class="break">
<h3 class="subsection_title">
<a name="GUI2.3.3">13.3.3&nbsp;&nbsp;ListView and ComboBox</a>
</h3>


<p>A <span class="classname">ListView</span> is a control that represents a list
of items that can be selected by the user.  It is also possible to let the
user edit items in the list.  The sample program
<span class="sourceref"><a href="../source/chapter13/SillyStamper.java">SillyStamper.java</a></span> allows the user to select
an icon (that is, a small image) in a <span class="classname">ListView</span> of icons.
The user selects an icon in the list by clicking on it.
The selected icon can be "stamped" onto a canvas by clicking on
the canvas. Shift-clicking adds a larger version of the image to the canvas.
(The icons in this program are from the KDE desktop project.)
Here is a picture of the program with several icons already stamped onto the
drawing area and with the "star" icon selected in the list:</p>


<p align="center">
<img src="silly-stamper.png" width="394" height="286" alt="screenshot from SillyStamper.java"></p>   
   

<p>
<span class="classname">ListView</span> is defined in package <span class="code">javafx.scene.control</span>. It is a parameterized
type, where the type parameter indicates what type of object can be displayed in the list.
The most common type is probably <span class="atype">ListView&lt;String&gt;</span>, but in the sample program,
it's <span class="atype">ListView&lt;ImageView&gt;</span>.  A <span class="classname">ListView</span>
can display <span class="classname">Strings</span> and <span class="classname">Nodes</span> directly.
When used with objects of other types, the default is to display the string representation
of the object, as returned by the <span class="code">toString()</span> method (which is often not very
useful).</p>


<p>The items in a <span class="atype">ListView&lt;T&gt;</span> are stored in an
<span class="atype">ObservableList&lt;T&gt;</span>.  The list of items is part of the model
for the <span class="classname">ListView</span>.  The list for a <span class="code">listView</span>
can be accessed as <span class="code">listView.getItems()</span>.  When items are added to
this list or deleted from the list, the list view is automatically updated
to reflect the change.</p>


<p>In the <span class="code">SillyStamper</span> program, the list is static.  That is, no changes
are made to the list after it has been created, and the user cannot edit the list.
The images for the icons are read from resource files, and each <span class="classname">Image</span> 
is wrapped in an  <span class="classname">ImageView</span> (<a href="../c6/s4.html#GUI1.4.1">Subsection&nbsp;6.4.1</a>),
which is added to the list of items in the <span class="classname">ListView</span>.
The list is constructed in the following method, which is called in the program's
<span class="code">start()</span> method:</p>


<pre>private ListView&lt;ImageView&gt; createIconList() {
    String[] iconNames = new String[] { 
               // names of image resource file, in directory stamper_icons
            "icon5.png", "icon7.png", "icon8.png", "icon9.png", "icon10.png",
            "icon11.png", "icon24.png", "icon25.png", "icon26.png", 
            "icon31.png", "icon33.png", "icon34.png"
    };

    iconImages = new Image[iconNames.length];  // Used for drawing the icons.

    ListView&lt;ImageView&gt; list = new ListView&lt;&gt;();

    list.setPrefWidth(80);
    list.setPrefHeight(100);

    for (int i = 0; i &lt; iconNames.length; i++) {
        Image icon = new Image("stamper_icons/" + iconNames[i]);
        iconImages[i] = icon;
        list.getItems().add( new ImageView(icon) );
    }

    list.getSelectionModel().select(0);  // Select the first item in the list.

    return list;
}</pre>


<p>This method sets a preferred width and height for the list.  The default preferred
size for a list seems to be about 200-by-400, no matter what it contains.  The icon
list needs a much smaller width.  The preferred height is set to a small value, but
in this program it will grow to fill the available space.  The default preferred height
would have forced the container to be bigger than I wanted.</p>


<p>The other point of interest is the use of the "selection model" of the list.
The selection model is the part of the model that records which items are selected
in the list.  By default, at most one item can be selected in a list, which is
the correct behavior for this program.  However, it would be possible to allow multiple items to be
selected at the same time by calling</p>


<pre>list.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);</pre>
   

<p>With the default single selection mode, when the user selects an item, the previously
selected item, if any, is deselected.  The user can select an item by clicking it,
and the program can set the selection by calling 
<span class="code">list.getSelectionModel().select(index)</span>.  The parameter is the index
of the item in the list, with numbering starting from zero as usual.
If <span class="code">index</span> is -1, than no item in the list is selected.  The selected
item in the list is highlighted in the list view.  The list view listens for
changes in the selection model.  When the user clicks an item, a mouse
listener (which is part of the controller) changes the selection model.
When that happens, the list view is notified of the change and
updates its appearance to reflect the fact that a different item is now selected.
A program can find out which item is currently selected by calling</p>
   

<pre>list.getSelectionModel().getSelectedIndex()</pre>


<p>In <span class="sourceref"><a href="../source/chapter13/SillyStamper.java">SillyStamper.java</a></span>, this method is used when the
user clicks on the canvas, to find out which icon should be stamped
into the picture.</p>


<hr class="break">


<p>The list in <span class="code">SillyStamper.java</span> is not editable. Our second
sample program, <span class="sourceref"><a href="../source/chapter13/EditListDemo.java">EditListDemo.java</a></span>, shows two lists
that can be edited by the user.  One is a list of strings and one is a list
of numbers.  The user can initiate editing of an item by double-clicking it,
or simply by clicking it if it is already selected.  The user finishes the edit
by pressing return or by hitting the escape key to cancel the edit.
Selecting another item in the list will also cancel the edit.</p>


<p align="center">
<img src="edit-list-demo.png" width="540" height="320" alt="Screenshot of EditListDemo.java"></p>


<p>There are a few things that you need to do if you want the user 
to be able to edit the items in a <span class="classname">ListView</span>.
The <span class="code">list</span> must be made editable by calling
</p>


<pre>list.setEditable(true);</pre>


<p>However, that by itself is not enough.  The individual cells in the list
must also be editable.  The term "cell" refers to an area in a list that
displays one item.  A list cell is an object that is responsible for
displaying the item and, optionally, implementing user editing of the
item.  Default list cells are not editable.</p>


<p>A <span class="classname">ListView</span> uses a <span class="newword">cell factory</span>
to create list cell objects.  The cell factory is another object that
is responsible for creating cells.  To get a different kind of cell,
you have to provide a different cell factory for the list.
(This follows something called the "factory pattern."  By using a
a factory object to create cells, the cells can be customized without
changing the <span class="classname">ListView</span> source code.  You simply
have to install a new cell factory.)</p>


<p>Writing cell factories is not a trivial task, but JavaFX has
several standard cell factories.  If <span class="code">listView</span> is
of type <span class="atype">ListView&lt;String&gt;</span>, you can install
a cell factory that makes editable cells simply by calling</p>


<pre>listView.setCellFactory( TextFieldListCell.forListView() );</pre>


<p>The method <span class="code">TextFieldListCell.forListView()</span> returns
a cell factory that creates cells that can display and edit strings.
When the cell is simply displaying the string, it actually uses
a <span class="classname">Label</span> for the display.  When the item
is being edited, it is displayed as a <span class="classname">TextField</span>.</p>


<p>That's all you need to know to make an editable list of strings.
There are other item types for which it is natural to display the
item as a string and to use a <span class="classname">TextField</span> for
editing the item.  That includes numbers, single character values,
dates, and times.  However, when the items are not strings, there
has to be some way to convert between items and their string
representations.  Again, JavaFX makes things reasonably easy in
the common cases: It provides standard converters for all of the
types mentioned above.  For example, if <span class="code">intList</span>
is an editable <span class="atype">ListType&lt;Integer&gt;</span>, you can
install an appropriate cell factory with</p>


<pre>intView.setCellFactory( 
           TextFieldListCell.forListView( new IntegerStringConverter() ) );</pre>
           

<p>The parameter to <span class="code">forListView</span> is an object that can convert
between integers and their string representations.  As it happens I was not
completely satisfied with the standard converter, since it didn't handle
illegal inputs in the text field very well, so for the list of integers in
the sample program <span class="sourceref"><a href="../source/chapter13/EditListDemo.java">EditListDemo.java</a></span>, I wrote my own
converter and used it create the cell factory for the list:</p>


<pre>StringConverter&lt;Integer&gt; myConverter = new StringConverter&lt;Integer&gt;() {
        // This custom string converter will convert a bad input string to
        // null, instead of just failing.  And it will display a null value
        // as "Bad Value" and an empty string value as 0.
        
    public Integer fromString(String s) {
            // Convert a string to an integer.
        if (s == null || s.trim().length() == 0)
            return 0;
        try {
            return Integer.parseInt(s);
        }
        catch (NumberFormatException e) {
            return null;
        }
    }
    
    public String toString(Integer n) {
            // Convert an integer to a String.
        if (n == null)
            return "Bad Value";
        return n.toString();
    }
};

listView.setCellFactory( TextFieldListCell.forListView( myConverter ) );</pre>


<p>As you can see, a <span class="classname">StringConverter</span> just has
to  define two functions, <span class="code">fromString()</span> and <span class="code">toString()</span>.</p>


<p>Standard string converters can be found in package <span class="code">javafx.util.converters</span>, and
the factory class <span class="code">TextFieldListCell</span> is in package <span class="code">javafx.scene.control.cell</span>.
There are also similar classes for use with cells in tables, which we will need below.</p>


<hr class="break">
           

<p>In addition to the lists themselves in the sample program, a few interesting things are
done with labels and buttons, by using observable properties of the <span class="classname">ListView's</span> model,
as discussed in <a href="../c13/s1.html#GUI2.1.2">Subsection&nbsp;13.1.2</a>.
For example, there are labels that show the selected index and the selected item in the list.
This is coded by binding the text property of the label with a property of the
list's selection model:</p>


<pre>Label selectedIndexLabel = new Label();
selectedIndexLabel.textProperty().bind(
                    listView.getSelectionModel()
                            .selectedIndexProperty()
                            .asString("Selected Index: %d") );

Label selectedNumberLabel = new Label();
selectedNumberLabel.textProperty().bind(
                    listView.getSelectionModel()
                            .selectedItemProperty()
                            .asString("SelectedItem: %s") );</pre>
                          

<p>And the button for deleting the selected item from the list should be enabled
only when there is actually a selected item.  This is coded by binding the
disable property of the button:</p>


<pre>deleteNumberButton.disableProperty().bind( 
                    listView.getSelectionModel()
                            .selectedIndexProperty()
                            .isEqualTo(-1) );</pre>
                          

<p>In effect, the labels and button are being used as alternative views of the
same selection model that is used by the list.  This is a major feature of the
MVC pattern:  There can be multiple views of the same model object.  The views listen
for changes in the model.  When the model changes, the views are notified of
the change and update themselves to reflect the new state of the model.</p>


<p>There is also an "Add" button that adds an item to the list.  This uses another
part of the <span class="classname">ListView</span> model.  The item is actually added
to the <span class="classname">ObservableList</span> that holds the items.  Since the
<span class="classname">ListView</span> listens for changes in that list, it will be notified of the change and
will update itself to show the new item in the visible on-screen view of the list.
Beyond adding the item to the observable list, no other action is needed in the program
to get the item to appear on the screen.</p>


<hr class="break">


<p>We can look briefly at another control, <span class="classname">ComboBox</span>,
that bears a lot of similarities to <span class="classname">ListView</span>.  In fact,
a <span class="classname">ComboBox</span> is basically a list view in which only the
selected item is normally visible.  When the user clicks on a combo box, the
full list of items pops up, and the user can select an item from the list.
In fact, a <span class="classname">ComboBox</span> actually uses a <span class="classname">ListView</span>
to show the items in the pop-up list.
You have seen combo boxes used as pop-up menus in some examples, starting 
with <span class="sourceref"><a href="../source/chapter1/GUIDemo.java">GUIDemo.java</a></span> all the way back in
<a href="../c1/s6.html">Section&nbsp;1.6</a>.  Like <span class="classname">ListView</span>, <span class="classname">ComboBox</span>
is a parameterized type.  Although other item types are supported
(using cell factories and string converters), <span class="classname">String</span>
is the most common type for the items.  Creating a combo box and managing
the selection is similar to working with <span class="classname">ListView</span>.
For example,</p>


<pre>ComboBox&lt;String&gt; flavors = new ComboBox&lt;&gt;();
flavors.getItems().addAll("Vanilla", "Chocolate", "Strawberry", "Pistachio");
flavors.getSelectionModel().select(0);</pre>


<p>It is possible to set a combo box to be editable (and no special cell factory
is needed for that, as long as the items are strings).  An editable combo
box is like a strange combination of text field and list view.  Instead of
using a label to show the selected item, the combo box uses a text field.
The user can edit the value in the text field, and the modified value becomes
the selected value in the combo box.  However, the original value of the modified item
is not removed from the list; the new item is just added.  And the new
item does not become a permanent part of the list.  In the above
example, the effect of saying <span class="code">flavors.setEditable(true)</span>
is to let the user type in "Rum Raisin," or anything else, as the selected
flavor, but doing so won't replace "Vanilla", "Chocolate", "Strawberry", 
or "Pistachio" in the list.</p>


<p>Unlike a <span class="classname">ListView</span>, a <span class="classname">ComboBox</span> emits
an <span class="classname">ActionEvent</span> when the user selects a new item, either
by selecting it from the pop-up menu or by typing a new value into an
editable combo box and pressing return.</p>




<hr class="break">
<h3 class="subsection_title">
<a name="GUI2.3.4">13.3.4&nbsp;&nbsp;TableView</a>
</h3>


<p>Like a <span class="classname">ListView</span>, a <span class="classname">TableView</span> control displays
a collection of items to the user.  However, tables are more complicated
than lists.  Table items are arranged in a grid
of rows and columns.  Each grid position is a cell of
the table.  Each column has a column header at the top, which
contains a name for the column.  A column contains a sequence of items,
and working with one of the columns
in a <span class="classname">TableView</span> is in many ways similar to
working with a <span class="classname">ListView</span>.</p>


<p>
<span class="atype">TableView&lt;T&gt;</span> is a parameterized type.  An object of the 
type parameter, <span class="classname">T</span>, contains all of the data for one
row of the table.  (It can contain additional data as well; the table can be
a view of just some of the available data.)  The data model for a <span class="code">table</span>
of type <span class="atype">TableView&lt;T&gt;</span> is an <span class="atype">ObservableList&lt;T&gt;</span>,
and it can be accessed as <span class="code">table.getItems()</span>.  You can add and delete rows
of the table by adding and deleting elements of this list.</p>


<p>To define a table, it's not enough to provide the class that represents the
rows of the table; you also have to say what data goes in each column of the
table.  A table column is described by an object of type <span class="atype">TableColumn&lt;T,S&gt;</span>,
where the first type parameter, <span class="classname">T</span>, is the same as the type
parameter of the table, and the second type parameter, <span class="classname">S</span>,
is the data type for the items that appear in the cells of that column.  The type
<span class="atype">TableColumn&lt;T,S&gt;</span> indicates that the column displays items of
type <span class="classname">S</span> derived from rows of type&nbsp;<span class="classname">T</span>. A table
column object does not contain the items that appear in the column; they are contained
in the objects of type <span class="classname">T</span> that represent the rows.
But the table column object needs to specify how to <b>get</b> the item that appears
in the column from the object that represents the row.  That is specified
by something called a "cell value factory."  It is possible to write a cell value factory that
computes any function of a row object, but the most common option is to use
a <span class="classname">PropertyValueFactory</span> that simply picks out one of the
properties of the row object.</p>


<p>Let's turn to an example.  The sample program <span class="sourceref"><a href="../source/chapter13/SimpleTableDemo.java">SimpleTableDemo.java</a></span>
shows an uneditable table that contains the fifty states of the United States with their capital cities
and population:</p>


<p align="center">
<img src="table-demo.png" width="354" height="161" alt="an example TableView"></p>


<p>The data for the rows of the table are in objects of type <span class="classname">StateData</span>,
which is defined in the program as a public static nested class.  (The class must be public for
use with a <span class="classname">PropertyValueFactory</span>; it does not need to be static or nested.)
The data values for a row are properties of the class, in the sense that there is a
getter method for each value.  Properties defined by getter methods are sufficient for
uneditable table values (though as we shall see, you need something different for editable table columns).  
Here is the class definition:</p>


<pre>public static class StateData {
    private String state;
    private String capital;
    private int population;
    public String getState() {
        return state;
    }
    public String getCapital() {
        return capital;
    }
    public int getPopulation() {
        return population;
    }
    public StateData(String s, String c, int p) {
        state = s;
        capital = c;
        population = p;
    }
}</pre>


<p>The table that displays the state data is created with</p>


<pre>TableView&lt;StateData&gt; table = new TableView&lt;&gt;();</pre>


<p>and an item for each of the fifty states is added to the table data model, which is stored in <span class="code">table.getItems()</span>.
Then the table column objects are created and configured and added to the table column model, which is stored in
<span class="code">table.getColumns()</span>:</p>


<pre>TableColumn&lt;StateData, String&gt; stateCol = new TableColumn&lt;&gt;("State");
stateCol.setCellValueFactory(
                new PropertyValueFactory&lt;StateData, String&gt;("state") );
table.getColumns().add(stateCol);

TableColumn&lt;StateData, String&gt; capitalCol = new TableColumn&lt;&gt;("Capital City");
capitalCol.setCellValueFactory(
                  new PropertyValueFactory&lt;StateData, String&gt;("capital") );
table.getColumns().add(capitalCol);

TableColumn&lt;StateData, Integer&gt; populationCol = new TableColumn&lt;&gt;("Population");
populationCol.setCellValueFactory(
                 new PropertyValueFactory&lt;StateData, Integer&gt;("population") );
table.getColumns().add(populationCol);</pre>


<p>The parameter to the <span class="classname">TableColumn</span> constructor is the
text that appears in the header at the top of the column.  As for the cell value
factories, remember that a cell value factory needs to pull the value for a cell
out of a row object of type <span class="classname">StateData</span>.
For the first column, the type of data is <span class="classname">String</span>,
so the property value factory takes an
input of type <span class="classname">StateData</span> and outputs a property value
of a type <span class="classname">String</span>.  The output value is the property
named "state" in the <span class="classname">StateData</span> object.  More simply,
the constructor</p>


<pre>new PropertyValueFactory&lt;StateData, String&gt;("state")</pre>


<p>creates a cell value factory that gets the value to be displayed in a
cell by calling <span class="code">obj.getState()</span>, where <span class="code">obj</span> is the
object that represents the row of the table which contains the cell.
The other two columns are specified similarly.</p>


<p>That's about all you need to know to create a table in which the user cannot
edit the contents of the cells.  By default, the user will be able to
change the column width by dragging a separator between two column
headers.  And the user can click a column header to sort the rows of the
table into increasing or decreasing order according to the values in
that column.  Both capabilities can be turned off by setting properties
of the <span class="classname">TableColumn</span> object, as we will do for the
next example.  The user can also rearrange the columns by dragging a
table header to the left or right.</p>


<hr class="break">


<p>The sample program <span class="sourceref"><a href="../source/chapter13/ScatterPlotTableDemo.java">ScatterPlotTableDemo.java</a></span> includes
an example of a user-editable table.  Each row in the table represents a point
in the plane, and the two columns contain the x-coordinates and the y-coordinates
of the points.  To add some interest, the program also shows the points on
a canvas; the canvas is a "scatter plot" with a small crosshair at the location
of each point.  In the picture, one of the x-coordinates is being edited:</p>


<p align="center">
<img src="scatter-plot.png" width="500" height="320" alt="editable list of points, with scatter plot"></p>


<p>We need a data type to represent the rows of the table.  It can be a simple
class, with two properties <span class="code">x</span> and <span class="code">y</span> that hold the
coordinates of a point.  However, for an editable table column, we can't use
simple properties defined by getters and setters.  The problem is that 
an editable column expects the property for that column to be an
<i>observable property</i> (see <a href="../c13/s1.html">Section&nbsp;13.1</a>).
More exactly, the class should follow the JavaFX pattern for observable properties:
The values for the properties named <span class="code">x</span> and <span class="code">y</span> should be stored in
observable property objects, and a point object, <span class="code">pt</span>, should have
instance methods <span class="code">pt.xProperty()</span> and <span class="code">pt.yProperty()</span>.  These methods
return the observable property objects so that they can be used to get and set
the property value.  Since the properties store <span class="ptype">double</span>
values, they can be of type <span class="classname">DoubleProperty</span>.
The data class for the table is defined as:</p>


<pre>public static class Point {
    private DoubleProperty x, y;
    public Point(double xVal, double yVal) {
        x = new SimpleDoubleProperty(this,"x",xVal);
        y = new SimpleDoubleProperty(this,"y",yVal);
    }
    public DoubleProperty xProperty() {
        return x;
    }
    public DoubleProperty yProperty() {
        return y;
    }
}</pre>


<p>The class <span class="classname">DoubleProperty</span> itself is an abstract class.
<span class="classname">SimpleDoubleProperty</span> is concrete subclass. whose
constructor requires the object that contains the property, the name of the
property, and the initial value of the property.  Support for adding
change and invalidation listeners to the property is already implemented
in this class.</p>


<p>With the <span class="classname">Point</span> class in hand, we can create the table
and add a few random points to it:</p>


<pre>table = new TableView&lt;Point&gt;();
points = table.getItems();

for (int i = 0; i &lt; 5; i++) { // add 5 random points to the table
    points.add( new Point(5*Math.random(), 5*Math.random()) );
}</pre>


<p>When a point is added to or deleted from the table, the canvas has
to be redrawn.  To implement that, we can add a listener to the list, <span class="code">points</span>,
that serves as the data model for the table:</p>


<pre>points.addListener( (Observable e) -&gt; redrawDisplay() );</pre>


<p>(The type for the parameter, <span class="code">e</span>, in the lambda expression is
given as <span class="classname">Observable</span> because an observable list
has two <span class="code">addListener()</span> methods that require a one-parameter
lamda expression.  The explicit type for <span class="code">e</span> makes it possible
for the compiler to tell which one is meant here: We are adding
an <span class="classname">InvalidationListener</span> rather than a
<span class="classname">ListChangeListener</span>.)</p>


<p>We have arranged for the canvas to be redrawn whenever a point is
added to or deleted from the table.  However, it will not be redrawn
when the user edits one of the points in the table.  That is not a change
in the list structure; it's a change inside one of the objects in the list.
To respond to such changes, we could add listeners to both of the 
observable properties in each <span class="classname">Point</span> object.
In fact, that's what the table does so that it can respond to any changes
in a point that might be made from outside the table. Since that seems a little extreme to
me, the program actually listens for a different kind of event to handle cell edits. 
A table has an observable property named
<span class="code">editingCell</span> whose value is the cell that is currently being
edited, if any, or is <span class="code">null</span> if no cell is being edited.
When the value of this property changes to <span class="code">null</span>, it 
means that an editing operation has been completed.  We can arrange for
the canvas to be redrawn after every editing operation by adding a
change listener to the <span class="code">editingCell</span> property:</p>


<pre>table.editingCellProperty().addListener( (o,oldVal,newVal) -&gt; {
    if (newVal == null) {
        redrawDisplay();
    }
});</pre>


<p>To complete the definition of the table, we have to define the columns.
As in any table, we need a cell value factory for each column, which can
be created using a property value factory; this follows the same pattern
as the previous example.  But for an editable column, we also need a
cell factory, just as we did for the editable list example above.
Similarly to that example, the cell factory can be created using</p>


<pre>TextFieldTableCell.forTableColumn(myConverter)</pre>


<p>where <span class="code">myConverter</span> is a <span class="atype">StringConverter&lt;Double&gt;</span>.
Furthermore, for this program, it makes sense to stop the user
from resizing the columns or sorting them.  Here is the complete
code for setting up one of the columns:</p>


<pre>TableColumn&lt;Point, Double&gt; xColumn = new TableColumn&lt;&gt;("X Coord");
xColumn.setCellValueFactory( new PropertyValueFactory&lt;Point, Double&gt;("x") );
xColumn.setCellFactory( TextFieldTableCell.forTableColumn(myConverter) );
xColumn.setSortable(false);
xColumn.setResizable(false);
xColumn.setPrefWidth(100);  // (Default size is too small)
table.getColumns().add(xColumn);</pre>


<p>The only other thing that is needed to make the table work is to set it
to be editable by calling <span class="code">table.setEditable(true)</span>.
As you can see, you need to do quite a lot to make a table work, especially
if it's an editable table.  However, tables are complex, and the code that
JavaFX makes you write to set up a table is much less than you would need to
implement a table directly.</p>


<p>By the way, you should pay attention to the way that we have exploited
the MVC pattern in this program.  The scatter plot is an alternative view
of the same data model that is shown in the table.  The data from the model
is used when the canvas is redrawn, and that happens in response to events
generated by changes in the model. It actually takes surprisingly <i>little</i>
thought and work to make sure that the scatter plot is always a correct view of
the data.</p>


<p>I urge you to study the <span class="sourceref"><a href="../source/chapter13/ScatterPlotTableDemo.java">source code</a></span>,
which is well-commented.  In addition to seeing the full details of the
<span class="classname">TableView</span>, you might be interested in looking at how
transforms (<a href="../c13/s2.html#GUI2.2.3">Subsection&nbsp;13.2.3</a>) are used when drawing the scatter plot.</p>


   

</div>
<hr>
<div align="right">
<small>
        [  <a href="s2.html">Previous Section</a> |
           <a href="s4.html">Next Section</a> |
           <a href="index.html">Chapter Index</a> | 
        <a href="../index.html">Main Index</a> ]
    </small>
</div>
</div>
</body>
</html>
